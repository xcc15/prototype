# -*- coding: utf-8 -*-
"""City Disease Records Prototype

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pohdwpP8MfqjNTWz8dgBbg1lVoTZ8XNt
"""

import streamlit as st
import pandas as pd
from datetime import datetime
import io
import uuid # For generating unique IDs

# --- Configuration & Initialization ---
st.set_page_config(layout="wide", page_title="City Disease Records System")

# Define file paths
DATA_FILE = "disease_records.csv"
USER_FILE = "user_accounts.csv"
BARANGAYS = ["Sta. Mesa", "Paco", "Tondo", "Sampaloc", "Intramuros", "Malate", "Ermita"]
ROLES = ['Staff', 'Admin']

# --- Utility Functions: Data and Auth ---

def init_data_files():
    """Ensures the necessary CSV files exist with proper headers and initial data."""
    # 1. Initialize Disease Records CSV
    try:
        df = pd.read_csv(DATA_FILE)
        # Ensure 'ID' column is present, add if missing
        if 'ID' not in df.columns:
             df.insert(0, 'ID', [str(uuid.uuid4()) for _ in range(len(df))])
             df.to_csv(DATA_FILE, index=False)
    except FileNotFoundError:
        data = {
            'ID': [str(uuid.uuid4()) for _ in range(3)],
            'Date': ['2023-10-01', '2023-10-15', '2024-01-20'],
            'Barangay': ['Tondo', 'Sta. Mesa', 'Paco'],
            'Disease_Name': ['Lepotospirosis', 'Dengue Fever', 'Rabies'],
            'Cases': [50, 150, 20],
            'Status': ['Outbreak', 'Monitoring', 'Stable']
        }
        df = pd.DataFrame(data)
        df.to_csv(DATA_FILE, index=False)

    # 2. Initialize User Accounts CSV
    try:
        pd.read_csv(USER_FILE)
    except FileNotFoundError:
        df = pd.DataFrame(columns=['Username', 'Password', 'Role'])
        # Add a placeholder admin and staff
        df.loc[0] = ['admin', 'adminpass', 'Admin']
        df.loc[1] = ['staff', 'staffpass', 'Staff']
        df.to_csv(USER_FILE, index=False)

@st.cache_data
def load_data(file_path):
    """Loads data from a CSV file. Uses caching for performance."""
    try:
        df = pd.read_csv(file_path)
        if 'Date' in df.columns:
            df['Date'] = pd.to_datetime(df['Date'], errors='coerce')
        return df
    except FileNotFoundError:
        return pd.DataFrame()

def save_data(df, file_path):
    """Saves a DataFrame to a CSV file (clears cache)."""
    df.to_csv(file_path, index=False)
    load_data.clear() # Clear cache after writing

def authenticate_user(username, password):
    """Checks credentials."""
    users_df = load_data(USER_FILE)
    user = users_df[(users_df['Username'] == username) & (users_df['Password'] == password)]

    if not user.empty:
        return True, user.iloc[0]['Role']
    return False, None

# --- State Management ---
if 'logged_in' not in st.session_state:
    st.session_state['logged_in'] = False
if 'user_role' not in st.session_state:
    st.session_state['user_role'] = None
if 'page' not in st.session_state:
    st.session_state['page'] = 'Dashboard' # Default public view

# Initialize files
init_data_files()

# --- Page Rendering Functions ---

def render_sidebar():
    """Renders the navigation links and login/logout (buttons on the left side)."""
    with st.sidebar:
        st.title("Paolo Aguilar")
        st.write("---")

        st.header("Public Access")

        # Public views
        if st.button("📊 Dashboard Overview", key="nav_dashboard"):
            st.session_state['page'] = 'Dashboard'
        if st.button("📈 Reports & Export", key="nav_reports"):
            st.session_state['page'] = 'Reports'

        st.markdown("---")

        # Admin/Staff views
        if st.session_state['logged_in']:
            st.header("Secure Access")

            # Staff/Admin Records Access
            if st.session_state['user_role'] in ['Admin', 'Staff']:
                if st.button("📝 Records (CRUD)", key="nav_records"):
                    st.session_state['page'] = 'Records'

            # Admin-only User Management Access
            if st.session_state['user_role'] == 'Admin':
                if st.button("⚙️ User Management", key="nav_usermanagement"):
                    st.session_state['page'] = 'User Management'

            st.markdown("---")
            st.write(f"Hello, **{st.session_state['user_role']}**!")
            if st.button("🚪 Logout", key="logout_btn"):
                st.session_state['logged_in'] = False
                st.session_state['user_role'] = None
                st.session_state['page'] = 'Dashboard'
                st.rerun()

        else:
            st.header("Admin/Staff Login")
            with st.form("login_form"):
                username = st.text_input("Username")
                password = st.text_input("Password", type="password")
                submitted = st.form_submit_button("Log in")

                if submitted:
                    success, role = authenticate_user(username, password)
                    if success:
                        st.session_state['logged_in'] = True
                        st.session_state['user_role'] = role
                        st.success(f"Welcome, {role}!")
                        # Redirect to a relevant page after login
                        st.session_state['page'] = 'Records' if role in ['Staff', 'Admin'] else 'Dashboard'
                        st.rerun()
                    else:
                        st.error("Invalid Username or Password")

def render_dashboard():
    """Renders the public-facing dashboard with data visualizations and map placeholder."""
    st.title("Dashboard")
    st.info("This is the public view, showing aggregate and anonymized data.")

    df = load_data(DATA_FILE)
    if df.empty:
        st.warning("No disease records available yet to display.")
        return

    # Ensure data types are correct for calculations and plots
    df['Date'] = pd.to_datetime(df['Date'], errors='coerce')
    df['Cases'] = pd.to_numeric(df['Cases'], errors='coerce').fillna(0).astype(int)

    col1, col2, col3, col4 = st.columns(4)

    with col1:
        total_cases = df['Cases'].sum()
        st.metric("Total Cases Recorded", f"{total_cases:,}")

    with col2:
        barangays_affected = df['Barangay'].nunique()
        st.metric("Barangays Affected", barangays_affected)

    with col3:
        top_disease = df.groupby('Disease_Name')['Cases'].sum().idxmax()
        st.metric("Most Prevalent Disease", top_disease if pd.notna(top_disease) else "N/A")

    with col4:
        st.metric("Last Updated Date", df['Date'].max().strftime('%Y-%m-%d') if pd.notna(df['Date'].max()) else "N/A")

    st.markdown("---")

    # Placeholder Map for API
    st.header("📍 Case Distribution Map (API Placeholder)")
    st.write("This section simulates an interactive map, which would typically be powered by a geospatial API (like Google Maps or Mapbox) using packages like **Folium** or **Streamlit's native map** to display coordinates associated with the Barangays.")

    # Fictional coordinates for a central city area
    map_data = pd.DataFrame({
        'lat': [14.6091, 14.5995, 14.6300, 14.6105, 14.5800, 14.5700, 14.5500],
        'lon': [121.0223, 120.9842, 121.0400, 121.0000, 120.9700, 120.9900, 121.0100],
        'Barangay': BARANGAYS
    })

    # Merge with actual case data for realistic size simulation
    summary_data = df.groupby('Barangay')['Cases'].sum().reset_index()
    map_data = map_data.merge(summary_data, on='Barangay', how='left').fillna(10)

    # Simulate size of points based on cases
    st.map(map_data, latitude='lat', longitude='lon', size='Cases', color='#FF4B4B')

    st.markdown("---")
    st.header("Key Trends and Analysis")

    # Cases by Barangay
    col_chart, col_table = st.columns(2)
    with col_chart:
        st.subheader("Total Cases by Barangay")
        barangay_summary = df.groupby('Barangay')['Cases'].sum().sort_values(ascending=True)
        st.bar_chart(barangay_summary)

    with col_table:
        st.subheader("Cases Over Time")
        time_series = df.groupby(df['Date'].dt.to_period('M'))['Cases'].sum().sort_index()
        time_series.index = time_series.index.astype(str) # Convert PeriodIndex to string for plotting
        st.line_chart(time_series)

def render_reports():
    """Renders the public reports page with filtering and CSV export."""
    st.title("📈 Public Reports: Data Export")
    st.write("Use the filters below to generate a specific report and export the data to a CSV file.")

    df = load_data(DATA_FILE)
    if df.empty:
        st.warning("No data available for reports.")
        return

    # --- Filtering Logic ---
    st.subheader("Filter Data Range")

    min_date = df['Date'].min() if pd.notna(df['Date'].min()) else datetime.now().date()
    max_date = df['Date'].max() if pd.notna(df['Date'].max()) else datetime.now().date()

    date_range = st.date_input(
        "Select Date Range:",
        value=(min_date, max_date),
        min_value=min_date,
        max_value=max_date
    )

    if len(date_range) == 2:
        start_date, end_date = date_range
        # Apply date filter
        filtered_df = df[(df['Date'] >= pd.to_datetime(start_date)) & (df['Date'] <= pd.to_datetime(end_date))]
    else:
        filtered_df = df.copy()

    barangay_filter = st.multiselect("Filter by Barangay", BARANGAYS, default=[])
    if barangay_filter:
        filtered_df = filtered_df[filtered_df['Barangay'].isin(barangay_filter)]

    st.markdown("---")
    st.subheader(f"Generated Report ({len(filtered_df)} Records)")
    st.dataframe(filtered_df, use_container_width=True)

    # --- Export to CSV ---
    if not filtered_df.empty:
        csv_data = filtered_df.to_csv(index=False).encode('utf-8')
        st.download_button(
            label="⬇️ Export Filtered Data to CSV",
            data=csv_data,
            file_name=f'disease_report_{datetime.now().strftime("%Y%m%d_%H%M%S")}.csv',
            mime='text/csv',
            help="Download the currently filtered data as a CSV file."
        )

def render_records():
    """Renders the staff/admin exclusive CRUD interface for disease records."""
    if st.session_state['user_role'] not in ['Admin', 'Staff']:
        st.error("Access Denied. Please log in as Staff or Admin.")
        return

    st.title("📝 Disease Records Management (CRUD)")
    st.write(f"Hello **{st.session_state['user_role']}**. Manage disease records here.")

    df = load_data(DATA_FILE)

    # --- CRUD Tabs ---
    tab1, tab2, tab3 = st.tabs(["➕ Add New Record", "✏️ Edit Existing Record", "🗑️ Delete Record"])

    # --- ADD Operation ---
    with tab1:
        st.subheader("Add a New Case Record")
        with st.form("add_form", clear_on_submit=True):
            new_id = str(uuid.uuid4())
            col_a1, col_a2 = st.columns(2)
            with col_a1:
                date = st.date_input("Date of Record", datetime.now().date())
                barangay = st.selectbox("Barangay", BARANGAYS)
                disease = st.text_input("Disease Name (e.g., Dengue)")
            with col_a2:
                cases = st.number_input("Number of Cases", min_value=1, step=1)
                status = st.selectbox("Current Status", ['Outbreak', 'Monitoring', 'Stable', 'Resolved'])
                st.write(f"System ID: `{new_id}`")

            add_submitted = st.form_submit_button("Add Record")

            if add_submitted:
                if disease and cases > 0:
                    new_record = pd.DataFrame([{
                        'ID': new_id,
                        'Date': date.strftime('%Y-%m-%d'),
                        'Barangay': barangay,
                        'Disease_Name': disease,
                        'Cases': cases,
                        'Status': status
                    }])
                    df = pd.concat([df, new_record], ignore_index=True)
                    save_data(df, DATA_FILE)
                    st.success(f"Record added for {disease} in {barangay} (Cases: {cases})!")
                    st.rerun()
                else:
                    st.error("Please fill in all required fields (Disease Name and Cases).")

    # --- EDIT Operation ---
    with tab2:
        st.subheader("Edit an Existing Record")

        # Create a dictionary for easier lookup (ID -> Disease_Name)
        id_options = {row['ID']: f"{row['Disease_Name']} - {row['Barangay']} ({row['Date'].strftime('%Y-%m-%d')})" for _, row in df.iterrows()}
        selected_id = st.selectbox("Select Record to Edit (ID - Disease - Date)", options=list(id_options.keys()), format_func=lambda x: id_options.get(x, x))

        if selected_id:
            record_index = df.index[df['ID'] == selected_id].tolist()[0]
            current_record = df.loc[record_index]

            with st.form("edit_form"):
                col_e1, col_e2 = st.columns(2)
                with col_e1:
                    edit_date = st.date_input("Date of Record", current_record['Date'].date(), key="edit_date")
                    edit_barangay = st.selectbox("Barangay", BARANGAYS, index=BARANGAYS.index(current_record['Barangay']), key="edit_barangay")
                    edit_disease = st.text_input("Disease Name", current_record['Disease_Name'], key="edit_disease")
                with col_e2:
                    edit_cases = st.number_input("Number of Cases", min_value=1, step=1, value=int(current_record['Cases']), key="edit_cases")
                    edit_status = st.selectbox("Current Status", ['Outbreak', 'Monitoring', 'Stable', 'Resolved'], index=['Outbreak', 'Monitoring', 'Stable', 'Resolved'].index(current_record['Status']), key="edit_status")
                    st.write(f"System ID: `{selected_id}`")

                edit_submitted = st.form_submit_button("Update Record")

                if edit_submitted:
                    df.loc[record_index, 'Date'] = edit_date.strftime('%Y-%m-%d')
                    df.loc[record_index, 'Barangay'] = edit_barangay
                    df.loc[record_index, 'Disease_Name'] = edit_disease
                    df.loc[record_index, 'Cases'] = edit_cases
                    df.loc[record_index, 'Status'] = edit_status

                    save_data(df, DATA_FILE)
                    st.success(f"Record ID {selected_id} updated successfully!")
                    st.rerun()

    # --- DELETE Operation ---
    with tab3:
        st.subheader("Delete a Record")

        # Use the same options for selection
        selected_id_delete = st.selectbox("Select Record to Delete", options=list(id_options.keys()), format_func=lambda x: id_options.get(x, x), key="delete_select")

        if selected_id_delete:
            record_to_delete = df[df['ID'] == selected_id_delete].iloc[0]
            st.warning(f"Are you sure you want to delete the record for **{record_to_delete['Disease_Name']}** in **{record_to_delete['Barangay']}** on **{record_to_delete['Date'].strftime('%Y-%m-%d')}** (Cases: {record_to_delete['Cases']})?")

            if st.button(f"Confirm Deletion of ID {selected_id_delete}"):
                df = df[df['ID'] != selected_id_delete]
                save_data(df, DATA_FILE)
                st.success(f"Record ID {selected_id_delete} deleted successfully.")
                st.rerun()

    st.markdown("---")
    st.subheader("Current Disease Records Table")
    st.dataframe(df.sort_values(by='Date', ascending=False), use_container_width=True)

def render_user_management():
    """Renders the admin exclusive interface for user CRUD."""
    if st.session_state['user_role'] != 'Admin':
        st.error("Access Denied. Only Admins can access User Management.")
        return

    st.title("⚙️ User Management (Admin Exclusive)")
    st.write("Manage Staff and Admin accounts for secure access.")

    users_df = load_data(USER_FILE)

    # --- Add User Form ---
    st.subheader("➕ Add New Staff/Admin")
    with st.form("add_user_form", clear_on_submit=True):
        col_u1, col_u2, col_u3 = st.columns(3)
        with col_u1:
            new_username = st.text_input("Username")
        with col_u2:
            new_password = st.text_input("Password", type="password")
        with col_u3:
            new_role = st.selectbox("Role", ROLES)

        add_user_submitted = st.form_submit_button("Create User Account")

        if add_user_submitted:
            if new_username and new_password:
                if new_username in users_df['Username'].values:
                    st.error("Username already exists.")
                else:
                    new_user = pd.DataFrame([{'Username': new_username, 'Password': new_password, 'Role': new_role}])
                    users_df = pd.concat([users_df, new_user], ignore_index=True)
                    save_data(users_df, USER_FILE)
                    st.success(f"New **{new_role}** user **{new_username}** created successfully.")
                    st.rerun()
            else:
                st.error("Username and Password are required.")

    st.markdown("---")
    st.subheader("Current User List")
    st.dataframe(users_df.drop(columns=['Password']), use_container_width=True) # Hide passwords in view

# --- Main Application Logic ---

render_sidebar()

# Route to the appropriate page
if st.session_state['page'] == 'Dashboard':
    render_dashboard()
elif st.session_state['page'] == 'Reports':
    render_reports()
elif st.session_state['page'] == 'Records':
    render_records()
elif st.session_state['page'] == 'User Management':
    render_user_management()
else:
    render_dashboard()